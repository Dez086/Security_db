

*******************************************************************************
                                PEP8 (STYLE)
*******************************************************************************

sudo apt-get update -y
sudo apt-get install -y pycodestyle

ClassNames
ErrorExceptionNames
variable_names
function_names
method_names
CONSTANTS_NAMES
packagenames
module_names

Trailing Commas is correct if put each value on a line by itself.
Limit all lines to a maximum of 79 characters.
Spaces are the preferred indentation method.

# Correct:
import os
import sys
from subprocess import Popen, PIPE
put at the top of the file, just after any module comments and docstrings,
    and before module globals and constants.
Imports should be grouped in the following order:
    Standard library imports.
    Related third party imports.
    Local application/library specific imports.
You should put a blank line between each group of imports.

income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends))

Core Python distribution code should use UTF-8 and no encoding declaration.

# Add some extra indentation on the conditional continuation line.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
# Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
# Add 4 spaces (an extra indentation) to distinguish arguments from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)



*******************************************************************************
                            None vs NaN
*******************************************************************************

None define a null value, or no value at all.
Missing values are NaN in numerical arrays and None in object arrays.
    --> foo is None     instead of      foo == None

np.nan in []np.nan]             # is true
np.nan == np.nan                # is false
np.nan is np.nan                # is true

NaN cannot be equal to NaN because NaN is the result of a failure,
    a failure can happen in multiple ways.

== (Value equality)                 # EVALUATES VALUES
    Ask if content of one variable is the sase as the content of another one.

is (Reference identity)             # EVALUATES IDs
    Ask if a variable is the same as another (share the same id-identity),
    if two variables point to the same object. 
    np.nan has one Id, always the same Id.

In (container)                      # EVALUATES IDs THEN VALUES
    Checks identity before checking equality. (x is y implies x = y)

if boolean (if not boolean)         # EVALUATES IF TRUE/FALSE
    Right way to evaluate boolean values. 
    Avoid if boolean == True, if boolean is True

if sequence (if not sequence)       # EVALUATES IF EMPTY/NOT EMPTY
    For sequences (str, lists, tuples) use that empty sequences are false.
    # Wrong: if len(seq):

if v is None (if v is not None)     # EVALUATES IF IS NONE/NOT NONE
    Comparisons to singletons like None should always be done with is/is not.




float('nan') is float('nan')    # is false. Creates != objects with != ids
float('nan') is np.nan          # is true.
np.isnan(float('nan'))          # is true.
pd.isna(float('nan'))           # is true.
pd.isnull(float('nan'))         # is true.

math.nan is float('nan')        # is false
math.isnan(float('nan'))        # is true.
math.nan is math.nan            # is true.
math.nan is np.nan              # is false

TypeError: 'float' object is no iterable --> can be because nan values in data.



*******************************************************************************
                        Pure functions vs Modifiers
*******************************************************************************

Side effects:
    Modification of variables received as parameters (by reference).
Pure function:
    Receive parameters, don't have side effects, return values.
Modifiers:
    Receive parameters, have side effects, return values.



*******************************************************************************
                                Doctest
*******************************************************************************

def make_matrix(rows, columns):
    """
       >>> m = make_matrix(3, 5)
       >>> m
       [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
       >>> m[1][1] = 7
       >>> m
       [[0, 0, 0, 0, 0], [0, 7, 0, 0, 0], [0, 0, 0, 0, 0]]
    """
    # return [[0] * columns] * rows     # Failed
    return [[0 for j in range(columns)] for i in range(rows)]

if __name__ == '__main__':
    import doctest
    doctest.testmod()

*******************************************************************************

https://docs.python.org/3/tutorial/index.html		# informal definition

https://docs.python.org/3/reference/index.html		# syntax and core semantics

https://docs.python.org/3/library/index.html		
	https://docs.python.org/3/library/functional.html
		https://docs.python.org/3/library/itertools.html
		https://docs.python.org/3/library/functools.html
		https://docs.python.org/3/library/operator.html


****************************** pipenv *****************************************
https://medium.com/@krishnaregmi/pipenv-vs-virtualenv-vs-conda-environment-
3dde3f6869ed
https://docs.pipenv.org/
https://rootnroll.com/d/pipenv/
https://pip.pypa.io/en/stable/reference/

pip install pipenv

INSIDE OF YOUR PROJECT DIRECTORY
pipenv install [--python 3.8]	# create a new environment by using.
						# This will look for a pipenv file, if it doesn’t exist
						# it will create a new environment and activate it.
pipenv shell 			# To activate you can run
pipenv install package		# Install new packages. Will add the package
							# to the pipenv file that’s called Pipfile
pipenv install <package> --dev	# install package for just the dev environement
pip list						# To chechk installed packages in environement
exit							# To exit env shell

pipenv run <shell_command>		# Run command in env but using actual shell.
pipenv run python main.py		# Run program in env but using actual shell.
pipenv run pip freeze			# Output installed packages requirements format
pip install --user requests		# install in local user directory if using envs

pipenv --rm						# Remove a Virtual Environment



*******************************************************************************

def func(arg_1, ..., arg_N, *args, kwarg_1, ..., kwarg_M, **kwargs):
    # do stuff
    return True
Where, in most typical cases;
    arg_i is an unnamed argument (positional arguments)
    args is a list, hence a set of unnamed arguments,
    kwarg_j is a named argument (non positional arguments)
    kwargs is a dictionary, hence a set of named arguments.

zip(*iterables)
The zip() function returns an iterator of tuples based on the iterable objects.

https://docs.python.org/3/library/timeit.html

https://hakibenita.com/fast-load-data-python-postgresql
Measuring Time
    To measure time for each method we use the built-in time module:
    >>> import time
    >>> start = time.perf_counter()
    >>> time.sleep(1) # do work
    >>> elapsed = time.perf_counter() - start
    >>> print(f'Time {elapsed:0.4}')
    Time 1.001
    import time
    def pc():
        start = time.perf_counter()
        time.sleep(1)
        print(time.perf_counter()-start)
    def pt():
        start = time.process_time()
        time.sleep(1)
        print(time.process_time()-start)
    pc()  # 0.99872320449432
    pt()  # 0.0
    perf_counter() should measure the real amount of time for a process to
        take, as if you used a stop watch.
    process_time() will give you the time spent by the computer for the current
        process, a computer with an OS usually won’t spend 100% of the time on
        any given process. This counter shouldn’t count the time the cpu is
        running anything else.

Most cases perf_counter is probably preferable but process_time can be useful if you want to compare code efficiency.
Measuring Memory
    To measure memory consumption, we are going to use the package memory-profiler.
    $ python -m pip install memory-profiler
    $ python -m memory_profiler example.py


from datetime import date, timedelta
start_date = date(2019, 1, 1)
end_date = date(2020, 1, 1)
delta = timedelta(days=1)
while start_date <= end_date:
    print(start_date.strftime("%Y-%m-%d"))
    start_date += delta



*******************************************************************************

import subprocess
completed = subprocess.run(args, *, stdin=None, input=None, stdout=None,
               stderr=None, shell=False, cwd=None, timeout=None, check=False,
               encoding=None, errors=None, env=None)
completed.returncode
subprocess.run("exit 1", shell=True, check=True)
subprocess.run(["ls", "-l", "/dev/null"], stdout=subprocess.PIPE)
b = subprocess.run("dir", shell=True, check=True, stdout=subprocess.PIPE)
b.stdout                                            // Bytes
str(b.stdout, encoding='utf-8', errors='ignore')     // String


*******************************************************************************

try:
    with open( "a.txt" ) as f :
        print f.readlines()
except EnvironmentError: # parent of IOError, OSError *and* WindowsError where available
    print 'oops'

To handle errors from the open call vs the working code:
try:
    f = open(filename, 'rb')
except IOError:
    print('error')
else:
    with f:
        print f.readlines()


*******************************************************************************

import os
print("PYTHONPATH:", os.environ.get('PYTHONPATH'))
print("PATH:", os.environ.get('PATH'))


https://recursospython.com/guias-y-manuales/obtener-lista-numeros-primos/


*******************************************************************************

properties.ini
    [EMAIL]
    user= <gmail username>
    password = <gmail password>

main.py
    import configparser
    config = configparser.ConfigParser()
    config.read('properties.ini')
    gmail_user = config['EMAIL']['user']
    gmail_password = config['EMAIL']['password']
    
    import smtplib
    gmail_user = '<input your gmail user. No need to use @gmail.com>'
    gmail_password = '<input your gmail password>'
    #email properties
    sent_from = gmail_user
    to = [<email_send_address>]
    subject = 'Alert for reduced in price'
    email_text = 
    """
    Alert for reduced in price
    """
    #email send request
    try:
        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.ehlo()
        server.login(gmail_user, gmail_password)
        server.sendmail(sent_from, to, email_text)
        server.close()
        print ('Email sent!')
    except Exception as e:
        print(e)
        print ('Something went wrong...')
''' If error and have double checked username and password, then open Gmail
Settings and Toggle on the Less Secure App Access Option.'''



*******************************************************************************
                            doctest
*******************************************************************************

def make_matrix(rows, columns):
    """
       >>> m = make_matrix(3, 5)
       >>> m
       [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
       >>> m[1][1] = 7
       >>> m
       [[0, 0, 0, 0, 0], [0, 7, 0, 0, 0], [0, 0, 0, 0, 0]]
    """
    return [[0 for j in range(columns)] for i in range(rows)]

if __name__ == '__main__':
    import doctest
    doctest.testmod()


*******************************************************************************
                            New features & 3.6+
*******************************************************************************


Python 3.6+
f-strings o literals strings. Runtime evaluated.
    course = 'Python'
    feature = 'f-strings'
    print(f"The new {course.upper()} feature is {feature} !")


from dataclasses import dataclass, asdict, field
@dataclass  #over a class
asdict(<instance>)  --> Convert the instance properties in a dictionary

dict(_id=5)       --> {_id: 5}

How to copy all properties of an object to another object
destination.__dict__.update(source.__dict__)

Formating and Style:
    Mypy (type checking)
    Black ¿?
    Pylint  # http://pylint.pycqa.org/en/latest/user_guide/ide-integration.html

3.8+
    class names(Enum):
        UNKNOWN = 'unknown'
        YOU = 'know'
    a = names.YOU   --> a.value # 'you'     --> a.name # know

    def func1(parameterA: Optional[<type>] = DefaultValue) -> Optional[<return_value>]:
    def parseV(value: Optional[str] = None) -> Optional[bool]:
    # Optional[str] means value can be type str or None



*******************************************************************************
                                Logging
*******************************************************************************

import logging

logging.basicConfig(format="%(asctime)-15s  %(message)s")
logger = logging.getLogger(__name__)


*******************************************************************************
                                Packages
*******************************************************************************

Core:
    Functions for: lists, iterators, types and meta-programming.
    Types: convertion (numerics, sequences, mappings, classes, etc) to another,
        comparisons, sorting, counting, etc.
    Utilities: Dataclasses for working with Data Objects, gettext for handling
        localization (l10n) and internationalization (i18n) of strings,
        json for converting to/from JSON, etc.

WebDev:
    FW Django > Flask > Bottle
    https://www.activestate.com/blog/
        the-top-10-python-frameworks-for-web-development/
    Data Analysis/Visualization:
        Pandas for working with data
        NumPy for working with arrays
        matplotlib for plotting data.
    ML: TensorFlow for modeling neural networks, Keras simplify TensorFlow,
        and Scikit-Learn for working with algorithms.

urllib3:    HTTP library with thread-safe connection pooling.
certifi:    providing Mozilla’s Certificate Authority (CA) Bundle
boto3:      Python implementation of the Amazon Web Services SDK
Pytest:     simple unit test to a more complex functional test.
Pywin32:    access to many of the native Windows API functions
Pandas:     manipulate and analyze large sets of data
statsmodels:
Tkinter:    framework for GUIs. Binds Python to the TK GUI toolkit. wxPython.
PyQT:       for building GUIs, heavier-duty GUI programming than Tkinter.
Requests:   sends HTTP requests. HTTP clients.
MoviePy:    videos. Common tasks, importing, modifying, and exporting.
Pillow:     images. Common tasks, importing, modifying, and exporting.
OpenCV:     images and videos. Mor advanced.
Pendulum:   datetime replacement.

https://www.activestate.com/blog/top-10-python-tools-to-make-your-life-easier/
#1 Simple Web Frameworks with Flask
#2 Web Scraping with Scrapy
#3 API Calls with Requests
#4 Command Line Packaging with Click
#5 Automated Testing with Selenium
#7 Generating Fake Data with Faker
#10 Code Template Creation with CookieCutter

6. Setuptools
5. Docutils: The Documentation Utilities project exists to create a set of tools to easily process plaintext documents into more useful file formats such as HTML, XMS, or LaTeX.
7. Pytest: Testing code fidelity 

https://stackoverflow.com/questions/1060279/iterating-through-a-range-of-dates-in-python
http://labix.org/python-dateutil


# How to import a parent package. Add it to PYTHONPATH
https://www.geeksforgeeks.org/python-import-from-parent-directory/
    from sys import path
    path.append("<dir>")
    import <module_in_dir> as mid


