


int array[] = {
    10, 1, 42, 3, 4, 42, 6, 7, -1, 9
};
size_t size = sizeof(array) / sizeof(array[0]);


*******************************************************************************
				Linear search
*******************************************************************************

Used for every kind of list.
runs in O(n) time, only looks forward.


Worst-case performance	O(n)
Best-case performance	O(1)
Average performance		O(n)
Worst-case space complexity	O(1) iterative

Sequentially checks each element of the list until it finds the target value.

L - List of n elements with values or records L0 .... Ln−1
T - Target value T,

Basic algorithm: Find the index of the target T in L.
    Set i to 0.
    	If Li = T, the search terminates successfully; return i.
    	Increase i by 1.
    If i < n, go to step 2.
	Otherwise, the search terminates unsuccessfully.

With a sentinel: just one to check if Li equals T
	// Add an extra record to the list (a sentinel value)
	Ln = T
    Set i to 0.
    If Li = T, go to step 4.
    	Increase i by 1 and go to step 2.
    If i < n, the search terminates successfully; return i.
	Else, the search terminates unsuccessfully.

In an ordered table: L0 ≤ L1 ... ≤ Ln−1
	// Sentinel greater than the target.
	Ln = T + 1
    Set i to 0.
    If Li ≥ T, go to step 4.
    Increase i by 1 and go to step 2.
    If Li = T, the search terminates successfully; return i.
	Else, the search terminates unsuccessfully.


*******************************************************************************
				Binary search
*******************************************************************************

Used in ordered list only.
runs in O(log n) time, looks both forward and backward

Worst-case performance			O(log(n))
Best-case performance			O(1)
Average performance				O(log(n))
Worst-case space complexity		O(1)

Space complexity O(log⁡ n). It takes O(n) space to store the array. 


// floor of... is the greatest integer less than or equal to...
function binary_search(A, n, T) is
    L := 0
    R := n − 1
    while L ≤ R do
        m := floor((L + R) / 2)
        if A[m] < T then
            L := m + 1
        else if A[m] > T then
            R := m - 1
        else:
            return m
    return unsuccessful


// ceiling of ... is the least integer greater than or equal to ...
// will return the index of the rightmost element if such an element exists
function binary_search_alternative(A, n, T) is
    L := 0
    R := n − 1
    while L != R do
        m := ceil((L + R) / 2)
        if A[m] > T then
            R := m - 1
        else:
            L := m
    if A[L] = T then
        return L
    return unsuccessful


// To find the leftmost element, 
function binary_search_leftmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] < T:
            L := m + 1
        else:

            R := m
    return L

// To find the rightmost element, 
function binary_search_rightmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] > T:
            R := m
        else:
            L := m + 1
    return R - 1

ISSUES

Midpoint calculated as (L+R)/2 --> L+R may exceed the range of integers.
If L and R are nonnegative, calculate midpoint: L + (R−L)/2


*******************************************************************************
				Jump search
*******************************************************************************

runs in O(roth n) time, looks forward and just one (or k) time(s) backward

Time Complexity : O(√n)
Auxiliary Space : O(1)

Used in ordered list, when is important if a jumping backwards takes more time than jumping forward. Just need to jump backwards 1 time or k-times.

1)	checks all items L(km), k natural and m is the block size
	until an item is found that is larger than the search key.
2a)	linear search is performed on the sublist L[(k-1)m, km]. 
2b)	performing multiple levels of jump search on the sublists,
	before finally performing the linear search.
	For an k-level jump search, optimum block size ml for the lth level
	(counting from 1) is n(k-l)/k.	*** best step size is m = √n.***
	Will perform k backward jumps in O(kn^(1/(k+1))) time. 

algorithm JumpSearch is
    input: An ordered list L, its length n and a search key s.
    output: The position of s in L, or nothing if s is not in L.
    
    a ← 0
    b ← ⌊√n⌋
    
    while Lmin(b,n)-1 < s do
        a ← b
        b ← b + ⌊√n⌋
        if a ≥ n then
            return nothing
    
    while La < s do
        a ← a + 1
        if a = min(b, n)
            return nothing
    
    if La = s then
        return a
    else
        return nothing

















https://en.wikipedia.org/wiki/Skip_list

https://en.wikipedia.org/wiki/Ternary_search

https://en.wikipedia.org/wiki/Uniform_binary_search
https://en.wikipedia.org/wiki/Binary_search_tree
https://en.wikipedia.org/wiki/Hash_table
https://en.wikipedia.org/wiki/Exponential_search
https://en.wikipedia.org/wiki/Interpolation_search
https://en.wikipedia.org/wiki/Fractional_cascading
https://en.wikipedia.org/wiki/Van_Emde_Boas_tree
https://en.wikipedia.org/wiki/Fusion_tree
https://en.wikipedia.org/wiki/Trie
https://en.wikipedia.org/wiki/Bit_array
https://en.wikipedia.org/wiki/B-tree

https://en.wikipedia.org/wiki/Binary_entropy_function

The Art of Computer Programming, Volumes 1-4A Boxed Set.
Third Edition (Reading, Massachusetts: Addison-Wesley, 2011), 3168pp.
ISBN 978-0-321-75104-1, 0-321-75104-3








